#### 														多线程

###### 1.并行和并发的区别

并行是指在同一时刻多个任务同时进行

并发是指在同一时间段多个任务“同时”进行

并行是不同实体上的多个事件，并发是同一实体上的多个事件

并行是并发的子集  

###### 2.线程和进程

线程是cpu调度和执行的最小单位 进程是资源分配的单位

进程有自己的内存空间 线程共享同一个进程下的内存空间

线程之间切换开销小，进程之前切换开销大

每个进程至少有一个线程 同一个进程下的多个线程可以并发执行

###### 3.守护线程

守护线程是服务线程，为主线程服务的，开启方式为当线程启动之前setdemon(true),当主线程停止后，无论守护线程是否执行完毕，虚拟机会shutdown掉，守护线程也会被关闭，主要用于日志打印

###### 4.创建线程的几种方式

(1)继承Thread类，重写run方法，新建子类的实例，调用子类的start方法开启线程 缺点在于java语言的单继承机制，不方便 不能去继承其他父类

(2)实现runable接口，重写run方法，新建实现类的实例对象target，然后将target当作参数传入thread的构造方法，实例化thread 调用thread 的start() 方法开启线程 解决了单继承的问题，但是只能单纯的执行方法 不能获取返回结果

(3)实现callable 接口  重写call接口，新建实现类的实例对象，将target传入futureTask 的构造方法构造task,将task 传入thread 构造thread  thread.start(), futureTask.get()可以获取返回值，好处在于可以执行方法并且获取返回值

###### 5.runable 和callable 的区别

runable接口方法只是单纯的执行方法，返回值是void 有些需要返回值的场景就很不方便

callable接口中的call方法可以有返回值，配合futureTask对象可以获取异步执行的返回值

###### 6.线程有哪些状态

线程有新生，就绪，运行，阻塞，死亡五个状态

新生new：当new一个线程时，未调用start方法时线程所处状态，此时并不去运行状态

就绪runable(可运行状态)：调用start()方法后，线程就进去了就绪状态，等待cpu分配时间片进入运行状态 线程切换 yiled()方法 阻塞结束 sleep结束 notify唤醒 都会使线程进入该状态 线程可以设置优先度，优先度高线程有更大概率被分配时间片运行 但是不绝对

运行状态 running 线程获取cpu时间片并运行 （running 和 runable 在有些资料中被归在了一起）

阻塞（blocked） 线程被其他操作赞同进入阻塞状态 io操作 sleep wait 以及等待其他线程释放锁

死亡（terminated） 线程正常运行结束或者调用stop方法进入死亡状态

###### 7.sleep() 和 wait() 有什么区别

sleep是Thread 类的静态方法，当前线程睡眠指定时间，睡眠时间结束后重新进去就绪状态和其他线程一起竞争cpu时间片，不会释放资源的锁

wait是object类的方法，会释放当前的锁，使线程进去等待池，直到调用notify方法或者被notifyall 才会重新进入锁池 也可以给一个wait 时间 时间结束后重回锁池，竞争对象锁 （只有锁池中的线程才有资格竞争对象锁并被执行）

###### 8.notify和notifyAll

notify 随机唤醒一个等待池的对象进入锁池，让它拥有竞争锁的资格

notifyall 唤醒所有等待池对象进入锁池，让他们拥有竞争锁的资格

竞争到锁的线程继续往下执行 ，而没有竞争到锁的线程继续留在锁池 等待下一次竞争机会

###### 9.run 和start 的区别

run方式只是单纯的执行这个方法，并没有真正开启多线程

start方法才会真正使当前线程进入就绪模式，开启多线程 等待cpu分配时间片

###### 10.池化技术的优势

首先池化技术可以更好地管理资源，避免无限制的创建线程占用大量空间导致oom，并且还可以避免频繁创建线程造成资源浪费

池化技术可以提高程序响应速度，线程也是一个对象，创建对象就需要时间

###### 11.创建线程池的方式

newFixedThreadPools(int size) 创建固定长度的线程池，当任务被提交如果当前线程池中的所有线程都在被使用那么会将当前任务放入队列中 当有空闲线程时才去执行该任务

newCachedThreadPool()创建一个可缓存的线程池，如果线程池的规模超过了处理需求，将自动回收空闲线程，而当需求增加时，则可以自动添加新线程，线程池的规模不存在任何限制。

newSingleThreadExecutor()这是一个单线程的Executor，它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来替代它；它的特点是能确保依照任务在队列中的顺序来串行执行。

 newScheduledThreadPool(int corePoolSize)创建了一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer。

###### 12.线程池的状态

###### 13.线程池的submit方法和excute 方法

callable 和 runable 的区别

subimit有返回值 excute没有返回值

submit 方便异常处理 可以抛出

###### 14.怎么保证多线程下的运行安全

根据java的内存模型 线程执行时，会先去将工作内存中的数据读取到本地寄存器，操作完之后再讲数据写出到工作内存

线程安全主要是通过三个方面决定的

原子性：这些代码要么全部执行，要么全部不执行，只有简单的赋值操作是原子操作，提供互斥访问，同一时间只能有一个线程可以访问资源（synchornized）

可见性：一个线程对内存数据的修改可以及时被其他线程看到（volatile synchornized）

有序性：程序执行的顺序按照代码的先后顺序执行 虚拟机会对指令重排序，指令重新排序的要求是不影响单线程的执行结果（volatile 禁止指令重排序 synchornized虽然允许指令重排序 但是他保证了同一时间只能有一个线程访问代码块 因此也可以认为是有序的 ）

###### 13.多线程锁的升级原理

###### 14.什么是死锁

死锁是指多个线程之间因为等待锁而产生的一种头衔尾等待的一种状态，若无外力作用他们将一直保持这种状态，举个例子 A线程占有锁1，需要请求锁2来进行下一步操作，但是这个时候线程B持有锁2，他需要请求锁1来执行下一步，就陷入了僵持状态

###### 15.怎么防止死锁

满足如下四个条件 才会产生死锁

互斥条件 同一时间只能有一个线程获取对象锁，其他线程只能处于等待状态

等待与保持 线程因请求其他对象的锁而陷入阻塞状态时，不会释放持有的锁。

不剥夺条件 线程已经占有的锁，不可以强行要求其释放锁 只能等待其使用完毕自行释放

循环等待  发生死锁后多个线程之间互相等待的状态

主要原因是请求与释放资源的顺序不当

条件1不可改变 可以通过合理的规划资源请求与释放的顺序，或者一次将所有需要的资源都请求到才执行下一步

###### 16.threadlocal是什么

###### 17.synchornized的实现原理

synchonized保证了同一时刻只能有一个线程获取该对象的锁，进入临界区，执行同步的代码块

jvm 的执行过程是线程将内存中的数据读取到缓存区，进行操作然后写出到工作内存中，因为这个互斥访问保证了原子性，并且这个线程操作完之后另一个线程再去将工作内存中的数据读取到缓存中 从而保证了可见性 尽管synchornized 不能禁止指令重新排序 但是指令重排序的原则是不会影响单线程下的执行结果，sysnchornized 的互质访问等价于多个线程串行执行，也保证了有序性

sysnchornized 可以同步对象方法块锁的是括号中的对象实例 同步方法锁的是当前对象  同步静态方法锁的是当前类 

###### 18.synchornized和volatile 

根据[Java内存模型](https://www.cnblogs.com/kaleidoscope/p/9505829.html)的实现，线程在具体执行时，会先拷贝主存数据到线程本地（CPU缓存），操作完成后再把结果从线程本地刷到主存。

volatile 的作用在于告诉jvm 当前变量是可变的，需要从去主存中读取；synchornized 锁定当前变量，只有当前线程可以访问该变量

volitile保证了变量的修改可见性，禁止指令重排序，保证了有序性，不能保证原子性

synchornized 保证了代码的有序性，hapen-before 原则对最后结果无影响，但是会发生指令重排序，可见性，原子性

volitile 只能修饰变量 synchornized 可以同步变量，类 方法块 对象

volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。

###### 19.synchornized和lock 的区别

synchornized 是个关键字 lock是个类

###### 20.sysnchornized和reentantLock

###### 21.atomic的原理