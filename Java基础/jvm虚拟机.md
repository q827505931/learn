### 				                              虚拟机

######  1.什么是虚拟机 

虚拟机是可以运行java代码的假想计算机，运行于操作系统上

主要组成 类加载器，运行时数据区 ， 执行引擎， 本地方法库 

执行流程，类加载器将java代码转为字节码加，字节码是JVM的一套指令语言，不能直接交给底层操作系统执行，运行时数据区将字节码加载到内存，执行引擎将字节码转化为底层操作系统识别的机器码，这中间会调用c语言编写的本地方法库

###### 2.JVM运行时数据区

运行时数据区主要包括以下部分 

​	程序技术器：用于线程间的上下文切换，记录执行到了哪条指令，这是个操作系统上的概念，每个线程都有自己的程序计数器，保证了线程切换后的正常执行

​	虚拟机栈：方法执行时的内存模型，每个方法被执行的时候都会同时创建一个栈帧，用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

​	本地方法栈：与虚拟机栈类似，只不过本地方法栈服务的是java代码执行过程中调用的本地方法

​	（以上三者是线程独立的 每个线程都有自己的程序计数器 虚拟机栈 本地方法栈）

​	堆：主要存储对象实例，线程共享 垃圾回收的主要场所 分代算法 后面展开

​	方法区：HotSpot虚拟机上中，又称很多人愿意把方法区称为“永久代”（Permanent Generation），本质上两者并不等价 用于存储加载的类信息 常量 静态变量 常量池也是方法区的一部分 字符串也会在常量池中创建

（后两者是线程共享的）

###### 3.堆栈的区别

堆和栈都是jvm运行时数据区的一部分，区别在于栈中的数据 是局部变量 堆中存储的是对象数据 栈中的数据更新速度更快，使用完会自行释放 堆中的数据更新速度慢，并且没有自行释放机制 会被垃圾回收机制不定时回收 下文展开

###### 4.队列和栈的区别

队列是先进先出的一种数据模型，只能在队尾插入，队首移除

栈是一种先进后出的数据结构，插入移除都只能在一端进行 典型的用处 后缀表达式

10+5*2/(3+5)  后缀表达式 10 5 2 3 5  +  /  *  + 右括号或者优先度高于当前栈顶符号 出栈

9 +（3 - 1） * 3  + 10 / 2    9 3 1 - 3 * + 10 2 / +

###### 5.双亲委派模型

首先说一下类相等的概念，类相等相求两个类本身相同并且类加载器相同

类加载器主要可以分为三类

启动类加载器：（bootstrap  classLoader）由c++写的，加载位于lib目录下的可以虚拟机识别的类库加载到内存， 它是虚拟机的一部分 可以通过--xbootstrap 指定目录并且可以被虚拟机识别的类库加载到内存

扩展类加载器（extension c.lassloader ） 扩展类加载器 加载ext目录下可以被虚拟机识别的类库或者被java/ext/dirs系统变量指定的类库

应用程序类加载器（application classloader） 加载用户类路径下的类库 默认加载器 

用户还可以通过继承 classloader 来自定义类加载器

双亲委派加载模型是指当接收到类加载请求后，当前类加载器会将类加载请求转移给上级类加载器，每个层次都是这样，最终所有的类加载请求都会到达启动类加载器，只有当上级类加载器无法完成类加载时才会尝试自己加载该类，通过这种方式保证了本身相同的类一定会被同一个类加载器加载。

###### 6类加载的过程

类加载的过程就是通过类的全限定名把java类代码转换为二进制流加载到内存，将类表示的静态存储结构转化为运行时存储结构，在内存中生成类的class对象，作为该类的数据访问接口 主要有以下几个步骤 加载 验证 准备 解析 初始化 

加载 ：根据类的全限定名去查询该类，并加载到内存 

验证：根据类的二进制流的魔数去验证该二进制文件是否可以当前虚拟机识别，该二进制流是否符合虚拟机规范

准备：对该类的静态变量分配内存并赋默认值，初始化常量

解析：将常量池的符号引用替换为直接引用

初始化：这个时候才真正开始执行类中的java 代码 ，对静态变量赋值 

初始化的时机 new 一个对象时，通过反射构建一个对象时候 初始化子类的时候会先初始化它的父类 虚拟机启动时含有 main方法的类会被初始化

###### 7.判断对象是否可以回收

主要有两种方法 引用计数器 和 可达性分析算法

引用计数器即每次有对象引用了这个对象 引用计数器+1，引用被释放时 引用计数器-1 当引用计数器值为0 的时候代表当前对象没有被引用 可以被回收

可达性分析算法即从GC Roots开始向下搜索，搜索走过的路径称为引用链，当一个对象没有被任何引用链关联到  那么就认为该对象是垃圾，可以被回收 

GC Roots 主要有四种 

本地方法栈中引用的对象 

虚拟机方法栈中的引用对象

方法区中常量引用的对象

方法区中类静态属性引用的对象   

###### 8.四种引用类型

强引用 Object obj = new Object(); 该引用永远不会被垃圾回收、

软引用 还有用但并非一定要存在的对象 在快要发生内存溢出之前 会先去回收软引用 

弱引用  只能存活到下次gc之前

虚引用 不会对该对象是否被垃圾回收产生任何影响

###### 9.垃圾回收算法

虚拟机中的垃圾回收主要是发生在堆中，堆内存可以分为新生代和老年代，垃圾回收是分代进行的，主要有标记清除算法 标记整理算法 复制算法三种 

复制算法：流程主要是将空间按照8：1：1分配 8为Eden空间 1为from  1 to 每次使用 Eden空间和from 空间 占满之后会将Eden空间与from 空间的对象复制到to空间 并且清空from 和 Eden 空间 然后原来的from 变成 to空间  显而易见 这种内存利用率不高 优势在于不会产生大量的内存碎片 主要用于新生代 ，因为新生代对象的生命周期短，每次垃圾回收都会清除大量对象。

标记清除算法：将未被引用链关联到的对象标记为垃圾。然后进行清除 优势在于效率相对更高，但是会产生大量的内存碎片  不连续空间 当分配大对象时容易因找不到合适的内存空间而触发下一次垃圾回收 主要用于老年代

标记整理算法：将未被引用链关联到的对象标记为垃圾，将垃圾清除后将其他对象往进行整理，移动到紧凑的状态

缺点在于效率相对降低 但是不会产生内存碎片 也是主要用于老年代 

###### 10.垃圾回收器

Serial 单线程的垃圾回收器 会造成用户进程的停顿 采用复制算法  

Serial Old 单线程老年代垃圾回收器  CMS的备选方案 标记整理算法

ParNew 多线程的新生代垃圾回收器 主要用于服务器端垃圾收集

Parallel  Scavenge  多线程环境下的新生代收集器 关注最大吞吐量

Parallel Old 与parallel Scavenge 配套使用 获取最大吞吐量

CMS 老年代垃圾回收器 关注最小停顿时间 标记清除算法 对资源敏感 无法处理浮动垃圾

G1 老年代新生代都可以用的垃圾回收器 兼顾最大吞吐量和最小停顿时间 可预测停顿  会维护一个优先度表 根据停顿时间来决定回收哪一部分垃圾

###### 11.CMS垃圾回收算法  

它是一种关注最小停顿时间的垃圾回收器，基于标记清除算法，会产生内存碎片  当内存碎片不能满足程序运行的时候会调用serial old 垃圾收集器完成老年代垃圾收集 影响性能 

###### 12.创建对象的过程

类加载检查  首先会去检查该类是否被加载过 若未被加载就会先去加载

分配内存 主要有两种方法  指针碰撞 标记整理方法得到的内存空间一边是使用过的内存 一边是未被使用过的内存 将指针移动一格至未被使用过的内存即可 空闲链表 标记清除算法得到的内存空间会由一个链表维护 当新建对象分配空间是会在链表中寻找未被使用且空间大于当前需要使用的内存碎片并分配给当前对象使用 更新链表状态

初始化零值 保证该对象实例在java中可用

设置对象头

执行初始化方法

###### 13.内存分配与回收策略

minor gc 与Full gc 

minor gc 发生在新生代的gc 执行时间快 执行更为频繁

full gc  新生代和老年代一起回收 执行较慢

 回收策略 

有限在新生代分配空间 

大对象直接进入老年代

新生代中的对象没每活过一次垃圾回收 年龄都会+1 默认情况下年龄大于15 会晋升为老年代

新生代的对象年龄动态确定 当相同年龄的对象超过surviour 空间的一半 这些对象会进入老年代

空间分配担保 当新生代发生minor gc 时 会先去判断老年代剩余空间是否大于新生代空间 若大于 则认为当前垃圾回是完全安全的 否则 会去比较当前老年代剩余空间是否大于历次新生代晋升老年代的对象所占内存的平均值 若大于 则尝试进行此次垃圾回收 否则会发生一次full gc 

发生full gc 的情况

显式调用system.gc()方法 空间分配担保失败 老年代空间不足